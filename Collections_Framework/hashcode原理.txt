-----hashcode概念-----
所有的对象，都有一个对应的hashcode（散列值）
比如字符串“Eason”对应的是1001 (实际上不是，这里是方便理解，假设的值)
比如字符串“Lebron”对应的是1004
比如字符串“James”对应的是1008
比如字符串“wyp”对应的也是1008

-----保存数据-----
准备一个数组，其长度是2000，并且设定特殊的hashcode算法，使得所有字符串对应的hashcode，都会落在0-1999之间
要存放名字为"Eason"的英雄，就把该英雄和名称组成一个键值对，存放在数组的1001这个位置上
要存放名字是"Lebron"的英雄，就把该英雄存放在数组的1004这个位置上
要存放名字是"James"的英雄，就把该英雄存放在数组的1008这个位置上
要存放名字是"wyp"的英雄，然而 "wyp"的hashcode 1008对应的位置已经有James英雄了，那么就在这里创建一个链表，接在"James"英雄后面存放wyp

-----查找数据-----
比如要查找Eason，首先计算"Eason"的hashcode是1001，根据1001这个下标，到数组中进行定位，（根据数组下标进行定位，是非常快速的） 发现1001这个位置就只有一个英雄，那么该英雄就是gareen.
比如要查找wyp，首先计算"wyp"的hashcode是1008，根据1008这个下标，到数组中进行定位，发现1008这个位置有两个英雄，那么就对两个英雄的名字进行逐一比较(equals)，因为此时需要比较的量就已经少很多了，很快也就可以找出目标英雄
这就是使用hashmap进行查询，非常快原理。

这是一种 用空间换时间 的思维方式 

However, HashSet的数据是不能重复的，相同数据不能保存在一起，到底如何判断是否是重复的呢？
根据HashSet和HashMap的关系，我们了解到因为HashSet没有自身的实现，而是里面封装了一个HashMap，所以本质上就是判断HashMap的key是否重复。

再通过上一步的学习，key是否重复，是由两个步骤判断的：
hashcode是否一样
	如果hashcode不一样，就是在不同的坑里，一定是不重复的
	如果hashcode一样，就是在同一个坑里，还需要进行equals比较
	如果equals一样，则是重复数据
	如果equals不一样，则是不同数据。 